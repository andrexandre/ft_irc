
//Por fazer
- Ver video a explicar como estrutar o projeto
- Ver aquilo dos setup server name or not e tambem o que e precisso por default.
- Ver sobre a verificaco do ficheiro
- Otimizar codigo
- Tomar atencao apara nao fechar a conexao sem querer
- Tomar atencao na ordem de fazer handle dos resquests e dos responses
- Fazeer timeout para que o ver a ultima vez que o cliente vez um request

//A fazer





//Feito
- Logica para que o parser consiga lidar com multiplos servers blocks
- Funcao do parsing para a diretiva listen
- Funcao do parsing para a diretiva root
- Funcao do parsing para a diretiva server_name
- Funcao do parsing para a diretiva Index
- Funcao do parsing para a diretiva autoindex
- Funcao do parsing para a diretiva error_page
- Funcao do parsing para a diretiva _host
- Funcao do parsing para a diretiva allowedMethods
- Funcao do parsing para a diretiva return
- Funcao do parsing para a diretiva client_max_body_size
- Verificar se mesmo que a diretiva exista ver se tem algo a frente
- Logica para o location block
- Location block parsing
- Ver se existe server Blocks duplicados(mesma porta, server_name e host)
- Funcoes para ver se as diretivas estao prenchidas
- Ver se existe coisas antes de encontar um Server_block
- Funcao do parsing para a diretiva CGI
- Fazer os getrs para os metodos do server 
- Fazer os getrs para os metodos do location block
- Fazer funcao que faz parsing do listen junto com o host

































VERSOES DE Funcoes



//v2
int WebServ::server_core(void)
{
	signal(SIGINT, handler);
	std::vector<int> listFds;
	struct epoll_event ev, evs[7]; //pesquisar coisas
	// std::ifstream test("index.html");// apagar depois
	int new_sock;
	try
	{
		struct sockaddr_in address;
		int addrlen = sizeof(address);
		bzero(&address, addrlen);
		address.sin_family = AF_INET;
		address.sin_addr.s_addr = htons(INADDR_ANY); // INADDR_ANY: any ip address
		int port = this->_servers[0]->getPort()[0];
		address.sin_port = htons(port);
		cout << "Server opened to any address on port: " << port << endl;
		// domain IPv4, service TCP, default protocol, port, interface, bklog
		// AF_INET,     SOCK_STREAM, 0,                8080, INADDR_ANY, 10
		serverSock = socket(AF_INET, SOCK_STREAM, 0);
		if (serverSock == -1)
			throw std::runtime_error("Error: Failed to create socket");
		int enable = 1;
		setNonBloking(&serverSock);
		if (setsockopt(serverSock, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(int)) < 0)
			throw std::runtime_error("Error: Failed to set setsockopt to SO_REUSEADDR");
		if (bind(serverSock, (struct sockaddr *)&address, addrlen) < 0)
			throw std::runtime_error("Error: Failed to bind socket or socket already open");
		int bklog = 10;
		if (listen(serverSock, bklog) < 0)
			throw std::runtime_error("Error: Failed to listen to socket");
		// epoll testing
		epSock = epoll_create(1);
		if (epSock < 0)
			throw std::runtime_error("Error: creating epoll instance");
		bzero(&ev, sizeof(ev));
		ev.events = EPOLLIN;
		ev.data.fd = serverSock;
		if (epoll_ctl(epSock, EPOLL_CTL_ADD, serverSock, &ev))
			throw std::runtime_error("Error: in adding server sock in the epoll instance");
		//end
		int event_count = 0;
		// int i = 1;
		listFds.push_back(serverSock);
		static int j;
		while (true)
		{
			cout << "\nPolling for input " << j << "..." << endl;
			event_count = epoll_wait(epSock, evs, 7, -1);
			if (event_count == -1)
				throw std::runtime_error("Error: no event ocurred");
			cout << "EVENTS READY: " << event_count << '\n' << endl;
			for (int i = 0; i < event_count; i++)
			{
				cout << RED << "Socket that was ready: " << evs[i].data.fd  << " and the event: " << evs[i].events << END << endl;
				if (evs[i].data.fd == serverSock && evs[i].events & EPOLLIN)
				{
					//o sokect do client vai para a classe cliente
					cout << "NEW REQUEST TO THE SERVER" << endl;
					if ((new_sock = accept(serverSock, (struct sockaddr *)&address, (socklen_t *)&addrlen)) < 0)
						throw std::runtime_error("Error: Failed to accept connection");					
					setNonBloking(&new_sock);
					ev.events = EPOLLIN ;
					ev.data.fd = new_sock;
					if (epoll_ctl(epSock, EPOLL_CTL_ADD, new_sock, &ev))
								throw std::runtime_error("Error: in adding server sock in the epoll instance");
					//setar  eles para non blockiing
					cout << "NEW ADDED CLIENTE TO THE SERVER" << "(fd: " << new_sock << ")" << endl;			
					listFds.push_back(new_sock);
				}
				else if (evs[i].events & EPOLLIN)
				{
					cout << "NEW REQUEST FROM CLIENTE TO THE SERVER" << endl;
					char buffer[30000];
					bzero(&buffer, sizeof(buffer));
					if (read(evs[i].data.fd, buffer, 30000) == -1)
						throw std::runtime_error("Error: in readind request");				
					cout << "Request received " << endl;				
					struct epoll_event tmp;
					tmp.events = EPOLLOUT;
					tmp.data.fd = evs[i].data.fd; 
					if (epoll_ctl(epSock, EPOLL_CTL_MOD, evs[i].data.fd, &tmp))
						throw std::runtime_error("CLIENT REMOVED with EPOLLHUP ");
				}
				else if (evs[i].events & EPOLLOUT)
				{
					std::stringstream ss;
					ss << j;
					string msg = "<html><h1>Hello, World ";
					msg += ss.str() + "!</h1></html>";
					string resp = "HTTP/1.1 200 OK\nContent-Type: text/html\nContent-Length: ";
					// msg = string(buffer); // Uncomment to send what we recieved instead of msg
					ss.str("");
					ss << msg.length();
					resp = resp + ss.str() + "\n\n" + msg;
					if (send(evs[i].data.fd, resp.c_str(), resp.length(), 0) == -1)
						throw std::runtime_error("Error: in sending the response");
					// cout << buffer << endl;
					cout << "response sent" << endl << endl;
					struct epoll_event tmp2;
					tmp2.events = EPOLLIN;
					tmp2.data.fd = evs[i].data.fd; 
					if (epoll_ctl(epSock, EPOLL_CTL_MOD, evs[i].data.fd, &tmp2))
					throw std::runtime_error("CLIENT REMOVED with EPOLLHUP ");	
					// break;
				}
				else
					cout << "invalid event" << endl;
			}
			j++;
		}
		cout << RED "Reached uncommon place" END << endl;
	}
	catch(const std::exception& e)
	{
		cerr << e.what() << " ðŸ’€" << '\n';
	}
	for (size_t i = 1; i < listFds.size(); i++)
	{
		epoll_ctl(epSock, EPOLL_CTL_DEL, listFds[i], NULL);
		close(listFds[i]);
	}
	close(serverSock);
	close(epSock);
	// test.close();// apagar depois
	return 0;
}





